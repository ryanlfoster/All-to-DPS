// Interface Variablesvar mainDialog;var confirmDialog;var chooseTemplate;var chooseExtension;var chooseDevice;var chooseColor;// Default Values// Use decimals otherwise the multiple article import will// have rounding errors and not allow a flattened stack.var PORTRAIT_PAGE_WIDTH = 1535.9999;var PORTRAIT_PAGE_HEIGHT = 2047.9999;var LANDSCAPE_PAGE_WIDTH = 2047.9999;var LANDSCAPE_PAGE_HEIGHT = 1535.9999;// Defines the Aspect Ratio of a pdf for optimal scaling    var PORTRAIT_ASPECT_RATIO = PORTRAIT_PAGE_WIDTH / PORTRAIT_PAGE_HEIGHT;// Defines the Geometric bounds used for optimal document creatonvar PORTRAIT_GEOMETRIC_BOUNDS = {geometricBounds: [0, 0, PORTRAIT_PAGE_HEIGHT, PORTRAIT_PAGE_WIDTH]};var LANDSCAPE_GEOMETRIC_BOUNDS = {geometricBounds: [0, 0, LANDSCAPE_PAGE_HEIGHT, LANDSCAPE_PAGE_WIDTH / 2]};// general File Variablesvar folderLocationvar folder;var pdfFile;var pdfFile1, pdfFile2;// Variable for the XMLvar sidecarStr;// Options Variablesvar chosenTemplate;var chosenExtension;var chosenDevice;var chosenColor;var chosenR;var chosenG;var chosenB;var chosenWidth;var chosenHeight;// Value Saving Variablesvar rBox;var gBox;var bBox;var widthBox;var heightBox;// Start the ScriptinitWindow();function initWindow() {   mainDialog = new Window("dialog","All To DPS Converter v0.2", undefined, {closeButton:true});   mainDialog.alignChildren = "left";   // Add Template Label   var templateLabel = mainDialog.add("statictext", undefined, "Choose a Template");   // Template DropDown   chooseTemplate = mainDialog.add("dropdownlist", undefined, ["Single pages", "Spreads"]);   chooseTemplate.selection = 0;   // File Extension   var extensionLabel = mainDialog.add("statictext", undefined, "Choose the file Extensions");   chooseExtension = mainDialog.add("dropdownlist", undefined, ["jpg", "jpeg", "png", "pdf"]);   chooseExtension.selection = 3;    // Screen Resolution   var screenSizeLabel = mainDialog.add("statictext",undefined,"Resolution Input (portrait)");   var screenSize = mainDialog.add("group");   widthBox = screenSize.add("edittext",undefined,"2048");   heightBox = screenSize.add("edittext",undefined,"1536");   // Background Color input   var bgcolorLabel = mainDialog.add("statictext", undefined, "Input RGB Values for background");   // ColorSpace Group   var colorGroup = mainDialog.add("group");   rBox = colorGroup.add("edittext", undefined, "255");   gBox = colorGroup.add("edittext", undefined, "255");   bBox = colorGroup.add("edittext", undefined, "255");   rBox.characters = 3;   gBox.characters = 3;   bBox.characters = 3;      //Add buttons   var mainButtons = mainDialog.add("group");   mainButtons.add("button", undefined, "OK", {name:"ok"});   mainButtons.add("button", undefined, "Cancel", {name:"cancel"});      // Detects wheter Ok or Cancel has been chosen    if(mainDialog.show() == 1) {        // Saves all needed values       chosenTemplate = chooseTemplate.selection.index;       chosenExtension = chooseExtension.selection.text;       chosenR = parseInt(rBox.text);       chosenG = parseInt(gBox.text);       chosenB = parseInt(bBox.text);              chosenWidth = parseInt(widthBox.text);       chosenHeight = parseInt(heightBox.text);              // opens up the Folder Browser window       chooseFolder();    } else {        exit();    }   // Shows the mainDialog   mainDialog.show();}function chooseFolder() {        // Changes the Values for the page Resolution        PORTRAIT_PAGE_WIDTH = chosenHeight - 0.0001;        PORTRAIT_PAGE_HEIGHT = chosenWidth - 0.0001;        LANDSCAPE_PAGE_WIDTH = chosenWidth - 0.0001;        LANDSCAPE_PAGE_HEIGHT = chosenHeight - 0.0001;                // Choose the location for your files        folderLocation = Folder.selectDialog("Choose the file location");                // if the location exists skip creation        if(!folderLocation)            return;                // Set the first line of the sidecar.xml file        sidecarStr = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><sidecar>";                // Use the TrimBox to trim inputed PDF files        app.pdfPlacePreferences.transparentBackground = false;        app.pdfPlacePreferences.pdfCrop = PDFCrop.CROP_TRIM;                folder = new Folder([folderLocation]);                // get the contents of the folder        var filename = "*.";        var fileExt = chosenExtension;        var fullName = filename+fileExt;        var contents = folder.getFiles(fullName);        var len = contents.length;                // Executes the appropriate action depending on the chosen template        if(chosenTemplate == 0) {                convertToSinglePages(contents, len);        } else {                convertToMultiPage(contents, len);        }}/////////////////////////////////////////////////                 Singe Page Docs                          /////////////////////////////////////////////////function convertToSinglePages(contents, length) {        for (i = 0; i < length; i++) {                pdfFile = contents[i];                createSinglePageDoc(PageOrientation.portrait, PORTRAIT_GEOMETRIC_BOUNDS, pdfFile, folder);                createSinglePageDoc(PageOrientation.landscape, LANDSCAPE_GEOMETRIC_BOUNDS, pdfFile, folder);        }        sidecarStr += "</sidecar>"		var file = new File(folder.toString() + "/forImportSingles/sidecar.xml");	file.open("w");	file.write(sidecarStr);	file.close();    // Close script when done    confirmDialog = new Window("dialog","Success", undefined, {closeButton:true});    confirmDialog.alignChildren = "center";   // Add Template Label   var templateLabel = confirmDialog.add("statictext", undefined, "De Conversie is klaar!");      //Add buttons     var confirmButtons = confirmDialog.add("group");     confirmButtons.add("button", undefined, "OK", {name:"ok"});        if(confirmDialog.show() == 1) {       exit();    } else {        exit();    }}function createSinglePageDoc(orientation, geometricBounds, pdfFile, folder) {	var doc = createDocument(orientation);	var page = doc.pages[0];    	var rect = page.rectangles.add(orientation == PageOrientation.portrait ? geometricBounds : {geometricBounds: [0, 0, LANDSCAPE_PAGE_HEIGHT, LANDSCAPE_PAGE_WIDTH]});    rect.fillColor = makeRGBForDoc(doc);	var pdf = page.place(pdfFile)[0];    	var fileName = getFileName(pdfFile);	if (orientation == PageOrientation.portrait) {		setSinglePDFProperties(pdf);		saveAndCloseDoc(doc, folder, fileName, fileName + "_v.indd", true);	} else {		alignSinglePDF(pdf);		saveAndCloseDoc(doc, folder, fileName, fileName + "_h.indd");	}}// Vertically or Horizontally aligns a single PDF on a page for portrait.function setSinglePDFProperties(pdf) {	var visibleBounds = pdf.visibleBounds;	var width = visibleBounds[3];	var height = visibleBounds[2];   	var rect = pdf.parent;	if (width / height > PORTRAIT_ASPECT_RATIO) { // Black bars above and below the content.		// Use the entire width.		var scale = PORTRAIT_PAGE_WIDTH / width;		rect.absoluteHorizontalScale = rect.absoluteVerticalScale = scale * 100;        		alignPDF(rect, width * scale, height * scale, PORTRAIT_PAGE_WIDTH, PORTRAIT_PAGE_HEIGHT);	} else if (width / height < PORTRAIT_ASPECT_RATIO) { // Black bars on the left and right side		// Use the entire width.		var scale = PORTRAIT_PAGE_WIDTH / width;		rect.absoluteHorizontalScale = rect.absoluteVerticalScale = scale * 100;        		alignPDF(rect, width * scale, height * scale, PORTRAIT_PAGE_WIDTH, PORTRAIT_PAGE_HEIGHT);	} else { // Scale width and height to take up entire page.        rect.absoluteHorizontalScale = (PORTRAIT_PAGE_WIDTH / width) * 100;		rect.absoluteVerticalScale = (PORTRAIT_PAGE_HEIGHT / height) * 100;     }}// Aligns a Single PDFfunction alignSinglePDF(pdf1) {    var availableWidth = LANDSCAPE_PAGE_WIDTH;    var visibleBounds = (pdf1).visibleBounds;    var width = visibleBounds[3];    var height = visibleBounds[2];            var scale = calculateScale(width, height, availableWidth, LANDSCAPE_PAGE_HEIGHT);                if (pdf1) {        pdf1.parent.absoluteHorizontalScale = pdf1.parent.absoluteVerticalScale = scale * 100;        alignPDF(pdf1.parent, width * scale, height * scale, availableWidth, LANDSCAPE_PAGE_HEIGHT, 0);    }    }/////////////////////////////////////////////////                 Multi Page Docs                          /////////////////////////////////////////////////function convertToMultiPage(contents, length) {        // Get the Cover       pdfFile = contents[length - 4];       // Create a portrait and Landscape version       createMultiPageDoc(PageOrientation.portrait, PORTRAIT_GEOMETRIC_BOUNDS, pdfFile, folder);       createMultiPageDoc(PageOrientation.landscape, PORTRAIT_GEOMETRIC_BOUNDS, pdfFile, folder);              length -= 4;              for (var j = 0; j < length; j++) {           if (j == 0) { // The first page after the cover.			// Combine the inside front cover (PCV0002__HRDP-120200.pdf) with the first pdf in the list (P003__HRDP-120200.pdf).			pdfFile1 = contents[length + 1]; // Inside front cover.			pdfFile2 = contents[j];		} else if (j == length - 1) { // The last page before the back cover.			// Combine the inside back cover (PCV0003__HRDP-120200.pdf) with the last pdf in the format P098__HRDP-120200.pdf.			pdfFile1 = contents[j];			pdfFile2 = contents[length + 2]; // Inside back cover		} else {			pdfFile1 = contents[j];			pdfFile2 = contents[j + 1];			j += 1;		}			createPortraitDoc(pdfFile1, pdfFile2, folder);		createLandscapeDoc(pdfFile1, pdfFile2, folder);	}    // Create the portrait back cover.	pdfFile = contents[contents.length - 1];	createMultiPageDoc(PageOrientation.portrait, PORTRAIT_GEOMETRIC_BOUNDS, pdfFile, folder);		// Create the landscape back cover.	createMultiPageDoc(PageOrientation.landscape, LANDSCAPE_GEOMETRIC_BOUNDS, pdfFile, folder, true);		sidecarStr += "</sidecar>"		var file = new File(folder.toString() + "/forImportMultiple/sidecar.xml");	file.open("w");	file.write(sidecarStr);	file.close();    // After done close script    confirmDialog = new Window("dialog","Success", undefined, {closeButton:true});    confirmDialog.alignChildren = "center";   // Add Template Label   var templateLabel = confirmDialog.add("statictext", undefined, "De Conversie is klaar!");      //Add buttons     var confirmButtons = confirmDialog.add("group");     confirmButtons.add("button", undefined, "OK", {name:"ok"});        if(confirmDialog.show() == 1) {       exit();    } else {        exit();    }}function createMultiPageDoc(orientation, geometricBounds, pdfFile, folder, isOffset) {	var doc = createDocument(orientation);	var page = doc.pages[0];		// Create the black background frame.	var rect = page.rectangles.add(orientation == PageOrientation.portrait ? geometricBounds : {geometricBounds: [0, 0, LANDSCAPE_PAGE_HEIGHT, LANDSCAPE_PAGE_WIDTH]});		rect.fillColor = makeRGBForDoc(doc);	var pdf = page.place(pdfFile)[0];		var fileName = getFileName(pdfFile);	if (orientation == PageOrientation.portrait) {		setSinglePDFProperties(pdf);		saveAndCloseDoc(doc, folder, fileName, fileName + "_v.indd", true);	} else {		if (isOffset)			alignDoublePDFs(null, pdf);		else			alignDoublePDFs(pdf);					saveAndCloseDoc(doc, folder, fileName, fileName + "_h.indd");	}}// Creates a document that contains two pages.function createPortraitDoc(pdfFile1, pdfFile2, folder) {	var doc = createDocument(PageOrientation.portrait);	var page = doc.pages[0];		var rect, page;		// Create the black background frame.	rect = page.rectangles.add(PORTRAIT_GEOMETRIC_BOUNDS);	rect.fillColor = makeRGBForDoc(doc);    	pdf = page.place(pdfFile1)[0];	setSinglePDFProperties(pdf);		page = doc.pages.add(); // Create a new page.		// Create the black background frame	rect = page.rectangles.add(PORTRAIT_GEOMETRIC_BOUNDS);	rect.fillColor = makeRGBForDoc(doc);		pdf = page.place(pdfFile2)[0];	setSinglePDFProperties(pdf);	var fileName = getFileName(pdfFile1);	saveAndCloseDoc(doc, folder, fileName, fileName + "_v.indd", true);}// Creates a document the contains one page with the PDFs side by side.function createLandscapeDoc(pdfFile1, pdfFile2, folder) {	var doc = createDocument(PageOrientation.landscape);	var page = doc.pages[0];	// Create the black background frame.	var rect = page.rectangles.add({geometricBounds: [0, 0, LANDSCAPE_PAGE_HEIGHT, LANDSCAPE_PAGE_WIDTH]});	rect.fillColor = makeRGBForDoc(doc);		var pdf1 = page.place(pdfFile1)[0];		var pdf2 = page.place(pdfFile2)[0];		alignDoublePDFs(pdf1, pdf2);	var fileName = getFileName(pdfFile1);	saveAndCloseDoc(doc, folder, fileName, fileName + "_h.indd");}// Aligns two PDFs on the same page in landscape.function alignDoublePDFs(pdf1, pdf2) {	var availableWidth = LANDSCAPE_PAGE_WIDTH / 2;	var visibleBounds = (pdf1 || pdf2).visibleBounds;	var width = visibleBounds[3];	var height = visibleBounds[2];		var scale = calculateScale(width, height, availableWidth, LANDSCAPE_PAGE_HEIGHT);		// Offsets used to align the page either to the left edge or the middle.	var offsetXPDF1 = 0;	var offsetXPDF2 = 0;	if (pdf1 && pdf2) {		offsetXPDF2 = availableWidth; // Offset the 2nd PDF so it is against the right edge of the 1st PDF.	} else if (pdf1 && !pdf2) { // Front cover. Position it so the x coord is the middle of the doc. Waiting for confirmation from Steve.		offsetXPDF1 = availableWidth;	}	if (pdf1) {		pdf1.parent.absoluteHorizontalScale = pdf1.parent.absoluteVerticalScale = scale * 100;		alignPDF(pdf1.parent, width * scale, height * scale, availableWidth, LANDSCAPE_PAGE_HEIGHT, offsetXPDF1);	}	if (pdf2) {		pdf2.parent.absoluteHorizontalScale = pdf2.parent.absoluteVerticalScale = scale * 100;		alignPDF(pdf2.parent, width * scale, height * scale, availableWidth, LANDSCAPE_PAGE_HEIGHT, offsetXPDF2);	}}/////////////////////////////////////////////////                 Document Functions                     /////////////////////////////////////////////////function createDocument(orientation) {		var doc = app.documents.add(false);	doc.viewPreferences.horizontalMeasurementUnits = MeasurementUnits.pixels;	doc.viewPreferences.verticalMeasurementUnits = MeasurementUnits.pixels;	doc.documentPreferences.pageWidth = PORTRAIT_PAGE_WIDTH + "px";	doc.documentPreferences.pageHeight = PORTRAIT_PAGE_HEIGHT + "px";	doc.documentPreferences.pageOrientation = orientation;	doc.documentPreferences.intent = DocumentIntentOptions.WEB_INTENT;	doc.documentPreferences.facingPages = false;		return doc;}function saveAndCloseDoc(doc, folder, fileName, file, isCreateSidecar) {        if(chosenTemplate == 0) {            var targetFolder = new Folder(folder.toString() + "/forImportSingles/" + fileName);        } else {             var targetFolder = new Folder(folder.toString() + "/forImportMultiple/" + fileName);        }	if (!targetFolder.exits)		targetFolder.create();			doc.save(new File(targetFolder.toString() + "/" + file));	doc.close();		// Sidecar entries cover both orientations a parameter is passed to only create them for one orientation.	if (isCreateSidecar) {		sidecarStr += "<entry>";		sidecarStr += "<folderName>" + fileName +"</folderName>";		sidecarStr += "<articleTitle></articleTitle>";		sidecarStr += "<byline></byline>";		sidecarStr += "<author></author>";		sidecarStr += "<kicker></kicker>";		sidecarStr += "<description></description>";		sidecarStr += "<tags></tags>";		sidecarStr += "<isAd>false</isAd>";		sidecarStr += "<smoothScrolling>never</smoothScrolling>";		sidecarStr += "<isFlattenedStack>true</isFlattenedStack>";		sidecarStr += "</entry>";	}}// Removes the path and file extension to return the file name.function getFileName(value) {	var path = value.toString();	var lastIndex = path.lastIndexOf("/");	var file = path.slice(lastIndex + 1);	var lastIndexPeriod = file.lastIndexOf(".");	return file.slice(0, lastIndexPeriod);}/////////////////////////////////////////////////                     Misc Functions                         /////////////////////////////////////////////////function calculateScale(width, height, targetWidth, targetHeight) {	return width / height > targetWidth / targetHeight ? targetWidth / width : targetHeight / height;}function alignPDF(rect, width, height, targetWidth, targetHeight, xOffset) {	if (!xOffset)		xOffset = 0;		xOffset = Math.round(xOffset);		if (width / height > targetWidth / targetHeight)		rect.move([xOffset, Math.round((targetHeight - height) / 2)]); // Center vertically	else		rect.move([Math.round((targetWidth - width) / 2) + xOffset, 0]); // Center horizontally.}/////////////////////////////////////////////////                 Colors functions                           /////////////////////////////////////////////////function makeRGBForDoc(doc) {	var color = doc.colors.item("color");	if (!color.isValid)		color = doc.colors.add({name: "color"});		color.properties = {space: ColorSpace.RGB, model: ColorModel.process, colorValue: [chosenR, chosenG, chosenB]};			return color;}function makeBlackForDoc(doc) {         	var color = doc.colors.item("black");	if (!color.isValid)		color = doc.colors.add({name: "black"});		color.properties = {space: ColorSpace.RGB, model: ColorModel.process, colorValue: [0, 0, 0]};			return color;}function makeWhiteForDoc(doc) {         	var color = doc.colors.item("white");	if (!color.isValid)		color = doc.colors.add({name: "white"});		color.properties = {space: ColorSpace.RGB, model: ColorModel.process, colorValue: [255, 255, 255]};			return color;}